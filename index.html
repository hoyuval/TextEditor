<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTL Text Editor</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Diff Match Patch Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <!-- Google Material Symbols Outlined -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <!-- Cousine Font -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Cousine:wght@400;500;600;700&display=swap">
    <style>
        :root {
            --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: 'Cousine', monospace;
        }
        /* Reset and Full Height Layout */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: var(--font-sans);
            background-color: #ffffff;
            color: #1f2937;
        }

        /* Material Icons sizing adjustments */
        .material-symbols-outlined {
            font-size: 1.25rem; /* 20px */
            line-height: 1;
        }

        /* Main Flex Container */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            padding: 1rem;
            box-sizing: border-box;
        }

        /* Header Section */
        .app-header {
            flex-shrink: 0;
            margin-bottom: 1rem;
        }
        h1 {
            font-size: 1.875rem;
            font-weight: 700;
            text-align: center;
            margin: 0 0 1rem 0;
        }

        /* Editor Section */
        .app-editor-area {
            flex-grow: 1;
            min-height: 200px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
        }

        /* Footer Section */
        .app-footer {
            flex-shrink: 0;
            max-height: 40vh;
            overflow-y: auto;
            border-top: 1px solid #e5e7eb;
            padding-top: 1rem;
        }

        /* Editor Grid Layout */
        .editor-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            height: 100%;
            width: 100%;
        }
        .editor-grid.comparison-active {
            grid-template-columns: 1fr 1fr;
        }

        /* Column Layout for Label + Editor */
        .editor-col {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        .editor-label {
            font-size: 0.875rem;
            font-weight: 700;
            color: #4b5563;
            margin-bottom: 0.25rem;
            padding-left: 0.25rem;
        }

        .editor-wrapper {
            position: relative;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
        }

        /* Text Input Styling */
        .text-input {
            flex-grow: 1;
            width: 100%;
            height: 100%;
            padding: 0.75rem;
            font-family: var(--font-mono);
            font-size: 1rem;
            line-height: 2;
            overflow-y: auto;
            word-wrap: break-word;
            white-space: pre-wrap;
            outline: none;
            background-color: #fff;
            box-sizing: border-box;
        }

        /* Visualization Overlay */
        .visualization-overlay {
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            position: absolute;
            pointer-events: none;
            overflow: hidden;
            z-index: 5;
        }

        .overlay-marker {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            font-weight: bold;
            color: #3b82f6;
            font-family: var(--font-mono);
        }
        .overlay-marker.highlight-match {
            background-color: rgba(255, 255, 0, 0.4);
            border-bottom: 2px solid #eab308;
            z-index: -1; 
        }
        .overlay-marker.break { transform: translateY(-50%); }
        .overlay-marker.space, .overlay-marker.tab, .overlay-marker.special { transform: translate(-50%, -50%); }
        .overlay-marker.space { font-size: 1rem; }

        /* UI Controls Styling */
        .control-row {
            display: flex;
            justify-content: flex-start; /* Aligned to Left */
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-btn, .action-btn, .secondary-btn {
            padding: 0.5rem;
            cursor: pointer;
            font-weight: 500;
            border-radius: 0.5rem;
            transition: all 0.2s;
            height: 2.5rem;
            min-width: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }
        .control-btn {
            background-color: #ffffff;
            color: #4b5563;
            border: 1px solid #d1d5db;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        .control-btn:hover { background-color: #e5e7eb; border-color: #9ca3af; }
        .control-btn:active { background-color: #f3f4f6; transform: translateY(1px); }
        .control-btn.is-active-btn { background-color: #4f46e5; color: white; border-color: #4f46e5; }
        
        .action-btn { background-color: #4f46e5; color: white; border: none; padding: 0.5rem 1rem;}
        .action-btn:hover { background-color: #4338ca; }
        .secondary-btn { background-color: #6b7280; color: white; border: none; padding: 0.5rem 1rem;}
        .secondary-btn:hover { background-color: #4b5563; }

        /* Toggle Containers */
        .toggle-container {
            display: flex;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            overflow: hidden;
            padding: 0.125rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            height: 2.5rem;
            background-color: #ffffff;
            align-items: center;
        }
        .toggle-container > .control-btn { 
            border: none; 
            box-shadow: none; 
            background: transparent; 
            height: 100%;
            border-radius: 0.375rem;
            padding: 0 0.75rem;
        }
        .toggle-container > .control-btn:hover { background-color: #e5e7eb; }
        .toggle-container > .control-btn.is-active-btn { background-color: #4f46e5; color: white; }

        /* Dropdowns */
        .dropdown-wrapper { position: relative; height: 2.5rem; display: flex; align-items: center; }
        .dropdown-wrapper .control-btn { height: 100%; }
        .dropdown-menu {
            position: absolute;
            z-index: 50;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
            margin-top: 0.25rem;
            top: 100%;
            left: 0;
        }
        #insertDropdownMenu { width: max-content; max-height: 300px; overflow-y: auto; }
        #substitutionsDropdownMenu { width: 350px; padding: 0.75rem; max-height: 400px; overflow-y: auto; }
        .dropdown-menu button {
            display: block; width: 100%; text-align: left; padding: 0.5rem 1rem;
            background-color: transparent; border: none; cursor: pointer;
        }
        .dropdown-menu button:hover { background-color: #f3f4f6; }
        .dropdown-input { border: 1px solid #d1d5db; border-radius: 0.5rem; padding: 0.5rem; width: 100%; box-sizing: border-box; }
        .substitution-row { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; }

        /* Find Bar */
        .find-bar {
            background-color: #f9fafb;
            border: 1px solid #d1d5db;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .find-row-inputs {
            display: flex;
            gap: 1rem;
            width: 100%;
        }
        .find-row-controls {
            display: flex;
            gap: 1rem;
            width: 100%;
            align-items: center;
            flex-wrap: wrap;
        }
        .find-input {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            font-family: var(--font-mono);
            font-size: 1rem;
            flex: 1;
        }
        #matchCounter {
            font-size: 0.9rem;
            color: #6b7280;
            white-space: nowrap;
            min-width: 100px;
            font-weight: 500;
        }

        /* Stats */
        #statsBar {
            font-family: var(--font-mono); font-size: 0.875rem; color: #6b7280;
            display: flex; gap: 2rem; margin-bottom: 1rem;
        }
        .stat-value { font-weight: 600; color: #374151; }

        /* Legend */
        .legend-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; margin-top: 1rem;}
        .legend-table th, .legend-table td { padding: 0.5rem 0.75rem; border: 1px solid #e5e7eb; }
        .legend-table th { background-color: #f9fafb; font-weight: 600; text-align: left; }

        /* Diff Colors */
        .diff-del { background-color: #fecaca; text-decoration: line-through; color: #991b1b; }
        .diff-ins { background-color: #bbf7d0; color: #166534; }
        
        .tag-highlight {
            background-color: #e0e7ff; /* Light indigo */
            color: #3730a3; /* Dark indigo */
            padding: 0.1rem 0.3rem;
            border-radius: 0.375rem;
            font-weight: 500;
        }

        .placeholder-highlight {
            background-color: #dcfce7; /* Light green */
            color: #166534; /* Dark green */
            padding: 0.1rem 0.3rem;
            border-radius: 0.375rem;
            font-style: italic;
        }

        .tag-highlight.paired-opener {
            position: relative;
            margin-right: 2px;
        }

        .tag-highlight.paired-opener::after {
            content: '';
            position: absolute;
            top: 50%;
            right: -6px; /* Adjust as needed */
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 6px solid #e0e7ff; /* Same as background color */
        }

        .hidden { display: none !important; }
        
        #messageDisplay {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            padding: 10px 20px; border-radius: 5px; color: white; z-index: 1000;
            opacity: 0; transition: opacity 0.5s; pointer-events: none; font-size: 1rem;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="app-header">
            <div class="control-row">
                <!-- Direction -->
                <div class="toggle-container">
                    <button id="btn-ltr" class="control-btn" onclick="setDirection('ltr')" title="LTR"><span class="material-symbols-outlined">format_textdirection_l_to_r</span></button>
                    <button id="btn-auto" class="control-btn" onclick="setDirection('auto')" title="Auto"><span class="material-symbols-outlined">hdr_auto</span></button>
                    <button id="btn-rtl" class="control-btn" onclick="setDirection('rtl')" title="RTL"><span class="material-symbols-outlined">format_textdirection_r_to_l</span></button>
                </div>

                <!-- Visualization Toggle -->
                <div class="toggle-container">
                    <button id="vizToggleButton" onclick="toggleVisualizationMode()" class="control-btn" title="Show Visualization">
                        <span class="material-symbols-outlined">visibility</span>
                    </button>
                </div>

                <!-- Tags and PHs Toggle -->
                <div class="toggle-container">
                    <button id="tagsPhsToggleButton" onclick="toggleTagsPhsMode()" class="control-btn" title="Enable Tags and Placeholders Mode">
                        <span class="material-symbols-outlined">sell</span>
                    </button>
                </div>

                <!-- Undo/Redo -->
                <div class="toggle-container">
                    <button class="control-btn" onclick="document.execCommand('undo')" title="Undo"><span class="material-symbols-outlined">undo</span></button>
                    <button class="control-btn" onclick="document.execCommand('redo')" title="Redo"><span class="material-symbols-outlined">redo</span></button>
                </div>

                <!-- Comparison Mode -->
                <div class="toggle-container">
                    <button id="comparisonBtn" onclick="toggleComparisonMode()" class="control-btn" title="Comparison Mode">
                        <span class="material-symbols-outlined">view_column_2</span>
                    </button>
                </div>

                <!-- Menus -->
                <div class="dropdown-wrapper">
                    <button id="insertDropdownBtn" class="control-btn" title="Insert Character"><span class="material-symbols-outlined">add</span></button>
                    <div id="insertDropdownMenu" class="dropdown-menu hidden">
                        <button onclick="insertControlChar('\u200F')">RLM – Right-to-Left Mark – ⎤</button>
                        <button onclick="insertControlChar('\u200E')">LRM – Left-to-Right Mark – ⎣</button>
                        <button onclick="insertControlChar('\u202B')">RLE – Right-to-Left Embedding – ⧼</button>
                        <button onclick="insertControlChar('\u202A')">LRE – Left-to-Right Embedding – ⧽</button>
                        <button onclick="insertControlChar('\u00A0')">NBSP – Non-breaking Space – ◦</button>
                        <button onclick="insertControlChar('\u2011')">NBH – Non-breaking Hyphen – ⸫</button>
                        <button onclick="insertControlChar('\t')">Tab – Tabulation – ↹</button>
                        <button onclick="insertControlChar('\u2013')">Dash – En Dash – –</button>
                        <button onclick="insertControlChar('\u2026')">Ellipsis – Horizontal Ellipsis – …</button>
                    </div>
                </div>

                <!-- Diff Toggle (At the end) -->
                <div class="toggle-container hidden" id="diffToggleContainer">
                    <button id="diffToggleButton" onclick="toggleDiffMode()" class="control-btn" title="Show Diffs">
                        <span class="material-symbols-outlined">text_compare</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Editor Area -->
        <div class="app-editor-area">
            <div id="editorGrid" class="editor-grid">
                <!-- Left Editor -->
                <div class="editor-col">
                    <div class="editor-label hidden" id="labelLeft">Original</div>
                    <div class="editor-wrapper">
                        <div id="textInput" class="text-input" contenteditable="true" spellcheck="false">Type or paste your text here...</div>
                        <div id="visualizationOverlay" class="visualization-overlay"></div>
                    </div>
                </div>
                
                <!-- Right Editor -->
                <div class="editor-col hidden" id="rightCol">
                    <div class="editor-label" id="labelRight">Modified</div>
                    <div class="editor-wrapper">
                        <div id="textInput2" class="text-input" contenteditable="true" spellcheck="false"></div>
                        <div id="visualizationOverlay2" class="visualization-overlay"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="app-footer">
            <div id="statsBar">
                <div class="stat-item">Character count: <span id="charCount" class="stat-value">0</span></div>
                <div class="stat-item">Excluding control characters: <span id="charCountNoControl" class="stat-value">0</span></div>
                <div class="stat-item">Word count: <span id="wordCount" class="stat-value">0</span></div>
            </div>

            <div class="find-bar">
                <div class="find-row-inputs">
                    <input type="text" id="findInput" placeholder="Find text..." class="find-input" oninput="updateMatchCount()">
                    <input type="text" id="replaceInput" placeholder="Replace with..." class="find-input">
                </div>
                <div class="find-row-controls">
                    <label style="font-size: 0.9rem; display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="regexToggle" onchange="updateMatchCount()" style="margin-right: 6px; width: 1rem; height: 1rem;"> 
                        Regex
                    </label>
                    <span id="matchCounter">0 matches</span>
                    <div style="flex-grow: 1;"></div> 
                    <button class="action-btn" onclick="findNext()">Find Next</button>
                    <button class="action-btn" onclick="highlightMatches()">Highlight Matches</button>
                    <button class="action-btn" onclick="replaceNext()">Replace Next</button>
                    <button class="action-btn" onclick="replaceAll()">Replace All</button>
                </div>
            </div>

            <div id="tagsPhsSection" class="find-bar">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="font-bold text-lg">Tags and PHs</h3>
                    <button class="action-btn" onclick="manualDetectAndRender()">Detect Tags</button>
                </div>
                <div id="tagsPhsContent" class="space-y-2 max-h-48 overflow-y-auto">
                    <p class="text-gray-500">Click "Detect Tags" to find tags and placeholders.</p>
                </div>
            </div>

            <div style="text-align: center; margin-bottom: 1.5rem; display: flex; justify-content: center; gap: 1rem;">
                <button class="action-btn" onclick="copyText()">Copy Text</button>
                <button class="secondary-btn" onclick="saveText()">Save File</button>
                <button class="secondary-btn" onclick="openFile()">Open File</button>
                <input type="file" id="fileInput" class="hidden" accept=".txt, .text, text/plain">
            </div>

            <table class="legend-table">
                <thead><tr><th>Name</th><th>Abbreviation</th><th>Visualization</th></tr></thead>
                <tbody>
                    <tr><td>Standard Space</td><td>Space</td><td><span style="color:#3b82f6; font-weight:bold;">·</span></td></tr>
                    <tr><td>Right-to-Left Mark</td><td>RLM</td><td><span style="color:#3b82f6; font-weight:bold;">⎤</span></td></tr>
                    <tr><td>Left-to-Right Mark</td><td>LRM</td><td><span style="color:#3b82f6; font-weight:bold;">⎣</span></td></tr>
                    <tr><td>Right-to-Left Embedding</td><td>RLE</td><td><span style="color:#3b82f6; font-weight:bold;">⧼</span></td></tr>
                    <tr><td>Left-to-Right Embedding</td><td>LRE</td><td><span style="color:#3b82f6; font-weight:bold;">⧽</span></td></tr>
                    <tr><td>Non-breaking Space</td><td>NBSP</td><td><span style="color:#3b82f6; font-weight:bold;">◦</span></td></tr>
                    <tr><td>Tab</td><td>Tab</td><td><span style="color:#3b82f6; font-weight:bold;">↹</span></td></tr>
                    <tr><td>Line Break</td><td>LB</td><td><span style="color:#3b82f6; font-weight:bold;">¶</span></td></tr>
                </tbody>
            </table>
        </div>
    </div>
    
    <div id="messageDisplay"></div>

    <script>
        // --- Elements ---
        const textInput = document.getElementById('textInput');
        const overlay = document.getElementById('visualizationOverlay');
        const textInput2 = document.getElementById('textInput2');
        const overlay2 = document.getElementById('visualizationOverlay2');
        
        const editorGrid = document.getElementById('editorGrid');
        const rightCol = document.getElementById('rightCol');
        const comparisonBtn = document.getElementById('comparisonBtn');
        const diffBtn = document.getElementById('diffToggleButton');
        const diffToggleContainer = document.getElementById('diffToggleContainer');
        const labelLeft = document.getElementById('labelLeft');
        const matchCounter = document.getElementById('matchCounter');

        // --- State ---
        let isVisualizationActive = false;
        let isTagsPhsModeActive = false;
        let tagsPhsState = {
            originalText: '',
            tags: []
        };
        let isComparisonMode = false;
        let isDiffActive = false;
        let activeInput = textInput; 
        let diffDebounceTimer;
        let lastSelectionRange = null; 
        
        // Define observers globally
        let observer1, observer2;
        const observerConfig = {childList: true, subtree: true, characterData: true};
        
        const dmp = new diff_match_patch();

        const DISPLAY_SYMBOLS = {
            ' ': '·', '\u200E': '⎣', '\u200F': '⎤', '\u202A': '⧽', '\u202B': '⧼',
            '\u00A0': '◦', '\u2011': '⸫', '\n': '¶', '\t': '↹', '\u2013': '–', '\u2026': '…'
        };
        const SPECIAL_CHARS_SET = new Set(Object.keys(DISPLAY_SYMBOLS));

        function updateLastSelection() {
            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                if ((textInput.contains(range.commonAncestorContainer)) || (textInput2.contains(range.commonAncestorContainer))) {
                    lastSelectionRange = range.cloneRange();
                }
            }
        }

        function detectTags(text) {
            const regex = /\\n|<[^>]+>|{\w+}|[A-Z]{2,}(?:_[A-Z]+)*/g;
            const matches = text.match(regex) || [];
            const uniqueTags = [...new Set(matches)];

            return uniqueTags.map(tag => {
                let type = 'placeholder';
                if (tag.startsWith('<') && tag.endsWith('>')) type = 'html';
                if (tag === '\\n') type = 'newline';

                return {
                    text: tag,
                    type: type,
                    renderOption: 'highlight',
                    placeholderText: '',
                    isPaired: isPaired(tag, uniqueTags)
                };
            });
        }

        function isPaired(tag, allTags) {
            if (!tag.startsWith('<') || !tag.endsWith('>')) return false;
            if (tag.startsWith('</')) return false; // It's a closing tag

            const tagName = tag.substring(1, tag.length - 1).split(' ')[0];
            const closingTag = `</${tagName}>`;
            return allTags.includes(closingTag);
        }

        // --- Visualization Logic ---
        function createMarker(text, rect, editorRect, parentOverlay, className = '') {
            const marker = document.createElement('div');
            marker.textContent = text;
            marker.className = `overlay-marker ${className}`;
            
            const left = rect.left - editorRect.left;
            const top = rect.top - editorRect.top;

            if (className === 'highlight-match') {
                 marker.style.width = `${rect.width}px`;
                 marker.style.height = `${rect.height}px`;
                 marker.style.left = `${left}px`;
                 marker.style.top = `${top}px`;
            } else if (className === 'break') {
                marker.style.left = `${left}px`;
                marker.style.top = `${top + (rect.height / 2)}px`;
                marker.style.transform = 'translateY(-50%)';
            } else {
                marker.style.left = `${left + (rect.width / 2)}px`;
                marker.style.top = `${top + (rect.height / 2)}px`;
            }
            parentOverlay.appendChild(marker);
        }

        function visualizeMatches(editorElement, overlayElement) {
            const findValue = document.getElementById('findInput').value;
            if (!findValue) return;

            const isRegex = document.getElementById('regexToggle').checked;
            let regex;
            try {
                regex = isRegex ? new RegExp(findValue, 'gi') : new RegExp(findValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            } catch(e) { return; }

            const walker = document.createTreeWalker(editorElement, NodeFilter.SHOW_TEXT);
            const range = document.createRange();
            const editorRect = editorElement.getBoundingClientRect();

            let node;
            while(node = walker.nextNode()) {
                let match;
                while ((match = regex.exec(node.nodeValue)) !== null) {
                    try {
                        range.setStart(node, match.index);
                        range.setEnd(node, match.index + match[0].length);
                        const rects = range.getClientRects();
                        for (let rect of rects) {
                            createMarker('', rect, editorRect, overlayElement, 'highlight-match');
                        }
                    } catch(e) {}
                }
            }
        }

        function applyVisualizationsForEditor(editorElement, overlayElement) {
            overlayElement.innerHTML = '';
            overlayElement.scrollTop = editorElement.scrollTop;
            overlayElement.scrollLeft = editorElement.scrollLeft;

            visualizeMatches(editorElement, overlayElement);

            if (!isVisualizationActive) return;

            const range = document.createRange();
            const editorRect = editorElement.getBoundingClientRect();
            
            const walker = document.createTreeWalker(editorElement, NodeFilter.SHOW_TEXT);
            let node;
            while(node = walker.nextNode()) {
                const textContent = node.nodeValue;
                for (let i = 0; i < textContent.length; i++) {
                    const char = textContent[i];
                    if (SPECIAL_CHARS_SET.has(char) && char !== '\n') {
                        try {
                            range.setStart(node, i);
                            range.setEnd(node, i + 1);
                            const rects = range.getClientRects();
                            if (rects.length > 0) {
                                let className = 'special';
                                if (char === ' ') className = 'space';
                                createMarker(DISPLAY_SYMBOLS[char], rects[0], editorRect, overlayElement, className);
                            }
                        } catch (e) {}
                    }
                }
            }

            const brs = editorElement.getElementsByTagName('BR');
            for(let br of brs) {
                const rect = br.getBoundingClientRect();
                if (rect.width === 0 && rect.height === 0) continue; 
                createMarker(DISPLAY_SYMBOLS['\n'], rect, editorRect, overlayElement, 'break');
            }
            
            for(let child of editorElement.children) {
                if(child.tagName === 'DIV') {
                    if (child.lastChild && child.lastChild.nodeType === Node.TEXT_NODE) {
                         range.selectNodeContents(child);
                         range.collapse(false);
                         const rects = range.getClientRects();
                         if(rects.length > 0) {
                             const r = rects[0];
                             const markerRect = { left: (window.getComputedStyle(editorElement).direction === 'rtl' ? r.left - 10 : r.right), top: r.top, width: 0, height: r.height };
                             createMarker(DISPLAY_SYMBOLS['\n'], markerRect, editorRect, overlayElement, 'break');
                         }
                    }
                }
            }
        }

        function applyAllVisualizations() {
            applyVisualizationsForEditor(textInput, overlay);
            if (isComparisonMode) applyVisualizationsForEditor(textInput2, overlay2);
        }

        // Stats & Logic
        function updateStats() {
            let text = activeInput.innerText;
            if (text === 'Type or paste your text here...' && activeInput.innerText.trim() === 'Type or paste your text here...') text = '';
            
            document.getElementById('charCount').textContent = text.length;
            document.getElementById('charCountNoControl').textContent = text.replace(/[\u200E\u200F\u202A-\u202E\u2060-\u206F\uFEFF\u200B]/g, '').length;
            document.getElementById('wordCount').textContent = text.trim() === '' ? 0 : text.trim().split(/\s+/).filter(w => w.length > 0).length;

            if (isDiffActive) {
                clearTimeout(diffDebounceTimer);
                diffDebounceTimer = setTimeout(updateRealTimeDiff, 500); 
            }
            updateMatchCount();
        }

        // Comparison & Diff
        function toggleComparisonMode() {
            isComparisonMode = !isComparisonMode;
            
            if (isComparisonMode) {
                comparisonBtn.classList.add('is-active-btn');
                comparisonBtn.innerHTML = '<span class="material-symbols-outlined">split_scene</span>';
                comparisonBtn.title = "Close Comparison";
                
                diffToggleContainer.classList.remove('hidden');
                rightCol.classList.remove('hidden');
                labelLeft.classList.remove('hidden');
                editorGrid.classList.add('comparison-active');
                
                textInput2.innerHTML = textInput.innerHTML;
                activeInput = textInput2;
                
                observer2.observe(textInput2, observerConfig);
            } else {
                comparisonBtn.classList.remove('is-active-btn');
                comparisonBtn.innerHTML = '<span class="material-symbols-outlined">view_column_2</span>';
                comparisonBtn.title = "Comparison Mode";

                if (isDiffActive) toggleDiffMode(); 

                diffToggleContainer.classList.add('hidden');
                rightCol.classList.add('hidden');
                labelLeft.classList.add('hidden');
                editorGrid.classList.remove('comparison-active');
                
                textInput.innerHTML = textInput2.innerHTML;
                activeInput = textInput;
                
                observer2.disconnect();
            }
            setTimeout(applyAllVisualizations, 300);
        }

        function updateRealTimeDiff() {
            if (!isDiffActive || !isComparisonMode) return;
            
            const s1 = textInput.scrollTop;
            const s2 = textInput2.scrollTop;

            const text1 = textInput.innerText; 
            const text2 = textInput2.innerText; 
            
            const diffs = dmp.diff_main(text1, text2);
            dmp.diff_cleanupSemantic(diffs);
            
            let htmlLeft = '';
            let htmlRight = '';
            
            diffs.forEach(part => {
                const type = part[0]; 
                let text = part[1].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>");
                
                if (type === 0) {
                    htmlLeft += text;
                    htmlRight += text;
                } else if (type === -1) {
                    htmlLeft += `<span class="diff-del">${text}</span>`;
                } else if (type === 1) {
                    htmlRight += `<span class="diff-ins">${text}</span>`;
                }
            });

            textInput.innerHTML = `<div>${htmlLeft}</div>`;
            textInput2.innerHTML = `<div>${htmlRight}</div>`;
            
            textInput.scrollTop = s1;
            textInput2.scrollTop = s2;

            applyAllVisualizations();
        }

        function toggleDiffMode() {
            isDiffActive = !isDiffActive;
            if (isDiffActive) {
                diffBtn.classList.add('is-active-btn');
                diffBtn.innerHTML = '<span class="material-symbols-outlined">article</span>';
                diffBtn.title = "Hide Diffs";
                updateRealTimeDiff();
            } else {
                diffBtn.classList.remove('is-active-btn');
                diffBtn.innerHTML = '<span class="material-symbols-outlined">text_compare</span>';
                diffBtn.title = "Show Diffs";
                
                const stripDiffTags = (el) => {
                    el.innerHTML = el.innerHTML.replace(/<span class="diff-(?:del|ins)"[^>]*>([\s\S]*?)<\/span>/g, '$1');
                };
                
                stripDiffTags(textInput);
                stripDiffTags(textInput2);
                
                setTimeout(applyAllVisualizations, 0);
            }
        }

        // Toggles & Actions
        function toggleVisualizationMode() {
            isVisualizationActive = !isVisualizationActive;
            const btn = document.getElementById('vizToggleButton');
            btn.classList.toggle('is-active-btn');
            btn.innerHTML = isVisualizationActive ? '<span class="material-symbols-outlined">visibility_off</span>' : '<span class="material-symbols-outlined">visibility</span>';
            btn.title = isVisualizationActive ? "Hide Visualization" : "Show Visualization";
            applyAllVisualizations();
        }

        function toggleTagsPhsMode() {
            isTagsPhsModeActive = !isTagsPhsModeActive;
            const btn = document.getElementById('tagsPhsToggleButton');
            btn.classList.toggle('is-active-btn');

            if (isTagsPhsModeActive) {
                btn.title = "Disable Tags and Placeholders Mode";
                // Before rendering, ensure the original text is up-to-date.
                tagsPhsState.originalText = activeInput.innerText;
                renderTagsAndPlaceholders();
            } else {
                btn.title = "Enable Tags and Placeholders Mode";
                // Reconstruct the text to preserve edits before reverting the view.
                tagsPhsState.originalText = reconstructOriginalText();
                activeInput.innerText = tagsPhsState.originalText;
            }
        }

        function manualDetectAndRender() {
            // If the mode is active, reconstruct the text to get the latest edits.
            const currentText = isTagsPhsModeActive ? reconstructOriginalText() : activeInput.innerText;
            tagsPhsState.originalText = currentText;
            tagsPhsState.tags = detectTags(currentText);
            updateTagsPhsPanel();
            if (isTagsPhsModeActive) {
                renderTagsAndPlaceholders();
            }
        }

        function updateTagsPhsPanel() {
            const contentDiv = document.getElementById('tagsPhsContent');
            contentDiv.innerHTML = '';

            if (tagsPhsState.tags.length === 0) {
                contentDiv.innerHTML = '<p class="text-gray-500">No tags or placeholders detected.</p>';
                return;
            }

            tagsPhsState.tags.forEach((tag, index) => {
                const row = document.createElement('div');
                row.className = 'substitution-row items-center';

                const tagTextDisplay = tag.text === '\\n' ? '\\n (newline)' : tag.text.replace(/</g, '&lt;');
                row.innerHTML = `
                    <input type="checkbox" id="tag-${index}-check" class="mr-2" ${tag.renderOption !== 'ignore' ? 'checked' : ''}>
                    <code class="font-mono bg-gray-200 px-1 rounded-md text-sm">${tagTextDisplay}</code>
                    <select id="tag-${index}-select" class="mx-2 border border-gray-300 rounded-md p-1">
                        <option value="highlight" ${tag.renderOption === 'highlight' ? 'selected' : ''}>Highlight</option>
                        <option value="render" ${tag.renderOption === 'render' ? 'selected' : ''}>Render as formatting</option>
                        <option value="placeholder" ${tag.renderOption === 'placeholder' ? 'selected' : ''}>Placeholder</option>
                    </select>
                    <input type="text" id="tag-${index}-input" class="dropdown-input ${tag.renderOption !== 'placeholder' ? 'hidden' : ''}" placeholder="Replacement text..." value="${tag.placeholderText}">
                `;

                contentDiv.appendChild(row);

                const checkbox = document.getElementById(`tag-${index}-check`);
                const select = document.getElementById(`tag-${index}-select`);
                const input = document.getElementById(`tag-${index}-input`);

                checkbox.addEventListener('change', () => {
                    tag.renderOption = checkbox.checked ? 'highlight' : 'ignore';
                    select.value = 'highlight'; // Reset to default when re-enabled
                    if (isTagsPhsModeActive) renderTagsAndPlaceholders();
                });

                select.addEventListener('change', () => {
                    tag.renderOption = select.value;
                    input.classList.toggle('hidden', select.value !== 'placeholder');
                    if (isTagsPhsModeActive) renderTagsAndPlaceholders();
                });

                input.addEventListener('input', () => {
                    tag.placeholderText = input.value;
                    if (isTagsPhsModeActive) renderTagsAndPlaceholders();
                });
            });
        }

        function renderTagsAndPlaceholders() {
            if (!isTagsPhsModeActive) return;

            let renderedText = tagsPhsState.originalText;

            tagsPhsState.tags.forEach(tag => {
                if (tag.renderOption === 'ignore') return;

                let replacement = '';
                switch (tag.renderOption) {
                    case 'highlight':
                        const className = `tag-highlight ${tag.isPaired ? 'paired-opener' : ''}`;
                        replacement = `<span class="${className}" data-tag-index="${tagsPhsState.tags.indexOf(tag)}">${tag.text.replace(/</g, '&lt;')}</span>`;
                        break;
                    case 'render':
                        replacement = tag.text === '\\n' ? '<br>' : tag.text;
                        break;
                    case 'placeholder':
                        const placeholderText = tag.placeholderText || tag.text;
                        replacement = `<span class="placeholder-highlight" data-tag-index="${tagsPhsState.tags.indexOf(tag)}">${placeholderText.replace(/</g, '&lt;')}</span>`;
                        break;
                }

                const tagRegex = new RegExp(tag.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                renderedText = renderedText.replace(tagRegex, replacement);
            });

            activeInput.innerHTML = renderedText.replace(/\n/g, '<br>');
        }

        function reconstructOriginalText() {
            const editor = activeInput.cloneNode(true);
            const spans = editor.querySelectorAll('span[data-tag-index]');

            spans.forEach(span => {
                const index = parseInt(span.getAttribute('data-tag-index'), 10);
                const originalTag = tagsPhsState.tags[index];
                if (originalTag) {
                    span.replaceWith(document.createTextNode(originalTag.text));
                }
            });

            return editor.innerText;
        }

        function setDirection(dir) {
            document.querySelectorAll('.toggle-container button').forEach(b => {
               if(b.id && b.id.startsWith('btn-')) b.classList.remove('is-active-btn');
            });
            const btn = document.getElementById(`btn-${dir}`);
            if(btn) btn.classList.add('is-active-btn');
            
            textInput.setAttribute('dir', dir);
            textInput2.setAttribute('dir', dir);
            applyAllVisualizations();
        }

        // Find & Replace
        function getMatchCount(text, regex) {
            if (!text || !regex) return 0;
            const matches = text.match(regex);
            return matches ? matches.length : 0;
        }

        function updateMatchCount() {
            const val = document.getElementById('findInput').value;
            const isRegex = document.getElementById('regexToggle').checked;
            
            if (!val) { 
                matchCounter.textContent = "0 matches"; 
                return; 
            }
            
            let regex;
            try {
                regex = isRegex ? new RegExp(val, 'gi') : new RegExp(val.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            } catch(e) { 
                matchCounter.textContent = "Invalid Regex"; 
                return; 
            }

            if (isComparisonMode) {
                const count1 = getMatchCount(textInput.innerText, regex);
                const count2 = getMatchCount(textInput2.innerText, regex);
                matchCounter.textContent = `${count1} (Orig) | ${count2} (Mod)`;
            } else {
                const count = getMatchCount(activeInput.innerText, regex);
                matchCounter.textContent = `${count} matches`;
            }
            applyAllVisualizations();
        }

        function findNext() {
            const val = document.getElementById('findInput').value;
            if(!val) return;
            
            // In comparison mode, always focus modified box first
            if (isComparisonMode) textInput2.focus();
            
            if(!window.find(val, false, false, true, false, false, false)) {
                // Wrap around
                const target = isComparisonMode ? textInput2 : activeInput;
                window.getSelection().collapse(target, 0);
                window.find(val, false, false, true, false, false, false);
            }
        }
        function highlightMatches() { applyAllVisualizations(); }
        
        function replaceNext() {
            const findVal = document.getElementById('findInput').value;
            const repVal = document.getElementById('replaceInput').value;
            if(!findVal) return;
            
            // Comparison mode: focus target right box
            if (isComparisonMode) textInput2.focus();

            const sel = window.getSelection();
            // In Comparison Mode, ensure selection is in the right box
            if (isComparisonMode && !textInput2.contains(sel.anchorNode)) {
                 findNext();
                 return;
            }

            if(!sel.isCollapsed && sel.toString().toLowerCase() === findVal.toLowerCase()) { 
                document.execCommand('insertText', false, repVal);
            }
            findNext();
        }
        
        function replaceAll() {
            const findVal = document.getElementById('findInput').value;
            const repVal = document.getElementById('replaceInput').value;
            if(!findVal) return;
            
            const isRegex = document.getElementById('regexToggle').checked;
            try {
                const regex = isRegex ? new RegExp(findVal, 'g') : new RegExp(findVal.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                
                // Target: Comparison Mode -> Right Box, Normal -> Active Box
                const target = isComparisonMode ? textInput2 : activeInput;
                
                const txt = target.innerText;
                const newTxt = txt.replace(regex, repVal);
                const lines = newTxt.split('\n');
                target.innerHTML = lines.map(l => `<div>${l.replace(/</g, '&lt;').replace(/>/g, '&gt;') || '<br>'}</div>`).join('');
                
                updateStats();
                applyAllVisualizations();
            } catch(e) { console.error(e); }
        }

        // Generic
        function insertControlChar(c) {
            activeInput.focus();
            document.execCommand('insertText', false, c);
            document.getElementById('insertDropdownMenu').classList.add('hidden');
            updateStats();
        }
        function showTemporaryMessage(msg) {
            const el = document.getElementById('messageDisplay');
            el.textContent = msg;
            el.style.backgroundColor = '#374151';
            el.style.opacity = '1';
            setTimeout(() => el.style.opacity = '0', 2000);
        }
        function copyText() {
            navigator.clipboard.writeText(activeInput.innerText).then(() => showTemporaryMessage('Copied!'));
        }
        function saveText() {
            const blob = new Blob([activeInput.innerText], {type: 'text/plain'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'text.txt';
            a.click();
        }
        function openFile() { document.getElementById('fileInput').click(); }

        // Init
        document.addEventListener('DOMContentLoaded', () => {
            const dropdowns = [
                {btn: 'insertDropdownBtn', menu: 'insertDropdownMenu'},
                {btn: 'substitutionsDropdownBtn', menu: 'substitutionsDropdownMenu'}
            ];
            dropdowns.forEach(d => {
                document.getElementById(d.btn).addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.getElementById(d.menu).classList.toggle('hidden');
                });
            });
            document.addEventListener('click', () => dropdowns.forEach(d => document.getElementById(d.menu).classList.add('hidden')));

            // Observers
            observer1 = new MutationObserver(() => {
                if(!isDiffActive) requestAnimationFrame(() => applyVisualizationsForEditor(textInput, overlay));
                if(activeInput === textInput) updateStats();
            });
            observer2 = new MutationObserver(() => {
                if(!isDiffActive) requestAnimationFrame(() => applyVisualizationsForEditor(textInput2, overlay2));
                if(activeInput === textInput2) updateStats();
            });
            observer1.observe(textInput, observerConfig);
            
            // Sync scrolling
            textInput.addEventListener('scroll', () => overlay.scrollTop = textInput.scrollTop);
            textInput2.addEventListener('scroll', () => overlay2.scrollTop = textInput2.scrollTop);
            
            // Cursor tracking for active input switching
            textInput.addEventListener('focus', () => { activeInput = textInput; });
            textInput2.addEventListener('focus', () => { activeInput = textInput2; });
            ['keyup', 'mouseup', 'input'].forEach(evt => textInput.addEventListener(evt, updateLastSelection));
            ['keyup', 'mouseup', 'input'].forEach(evt => textInput2.addEventListener(evt, updateLastSelection));

            setTimeout(() => setDirection('rtl'), 100);
        });
    </script>
</body>
</html>
